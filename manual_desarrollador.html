<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manual del Desarrollador - Dashboard de Ventas</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap');
        @import url("https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css");

        :root {
            --odoo-primary: #875A7B;
            --odoo-primary-dark: #6B4563;
            --text-primary: #2c3e50;
            --text-secondary: #555;
            --bg-light: #f8f9fa;
            --border-color: #e0e6ed;
            --accent-color: #3498db;
            --code-bg: #2d2d2d;
            --code-text: #f8f8f2;
        }

        body {
            font-family: 'Poppins', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            line-height: 1.7;
            color: var(--text-secondary);
            background-color: #fdfdff;
            margin: 0;
            display: flex;
        }

        #toc {
            width: 280px;
            position: fixed;
            top: 0;
            left: 0;
            height: 100vh;
            background: var(--bg-light);
            border-right: 1px solid var(--border-color);
            padding: 20px;
            overflow-y: auto;
        }

        #toc h2 {
            color: var(--odoo-primary);
            font-size: 1.5rem;
            margin-top: 0;
            border-bottom: 2px solid var(--odoo-primary-dark);
            padding-bottom: 10px;
        }

        #toc ul {
            list-style: none;
            padding: 0;
        }

        #toc li a {
            display: block;
            padding: 10px 15px;
            color: var(--text-secondary);
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease-in-out;
            font-weight: 500;
        }

        #toc li a:hover, #toc li a.active {
            background-color: var(--odoo-primary);
            color: white;
            transform: translateX(5px);
        }

        main {
            margin-left: 320px;
            padding: 40px;
            max-width: 900px;
            width: 100%;
        }

        section {
            margin-bottom: 60px;
            padding-top: 20px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 30px;
        }

        h1, h2, h3, h4 {
            color: var(--text-primary);
            font-weight: 600;
        }

        h1 {
            font-size: 2.8rem;
            color: var(--odoo-primary-dark);
            margin-bottom: 20px;
        }

        h2 {
            font-size: 2rem;
            border-bottom: 2px solid var(--odoo-primary);
            padding-bottom: 10px;
            margin-top: 0;
        }

        h3 {
            font-size: 1.4rem;
            color: var(--odoo-primary);
            margin-top: 30px;
        }

        h4 {
            font-size: 1.1rem;
            color: var(--text-primary);
            margin-top: 25px;
            border-left: 3px solid var(--accent-color);
            padding-left: 10px;
        }

        p, li {
            font-size: 1rem;
        }

        code {
            background-color: #e9ecef;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Courier New', Courier, monospace;
            color: #c7254e;
        }

        pre {
            background-color: var(--code-bg);
            color: var(--code-text);
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Fira Code', 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .note {
            background-color: #e7f3fe;
            border-left: 5px solid var(--accent-color);
            padding: 15px 20px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }

        .note strong {
            color: var(--accent-color);
        }

        .bi {
            margin-right: 8px;
        }
    </style>
</head>
<body>

    <nav id="toc">
        <h2><i class="bi bi-code-slash"></i>Dev Manual</h2>
        <ul>
            <li><a href="#introduccion">Introducción</a></li>
            <li><a href="#flujo-sales">Flujo de Datos: Ventas (/sales)</a></li>
            <li><a href="#flujo-pending">Flujo de Datos: Pendientes (/pending)</a></li>
            <li><a href="#sistema-cache">Sistema de Caché</a></li>
            <li><a href="#integracion-google-sheets">Integración con Google Sheets</a></li>
            <li><a href="#logica-dashboards">Lógica de los Dashboards</a></li>
        </ul>
    </nav>

    <main>
        <h1><i class="bi bi-gear-fill"></i>Manual del Desarrollador</h1>

        <section id="introduccion">
            <h2><i class="bi bi-diagram-3"></i>Introducción</h2>
            <p>
                Este manual describe la arquitectura y el flujo de datos de las secciones más importantes de la aplicación: las vistas de <strong>Ventas Facturadas</strong> (<code>/sales</code>) y <strong>Pedidos Pendientes</strong> (<code>/pending</code>).
            </p>
            <p>
                El objetivo es proporcionar una guía técnica para entender cómo se obtienen los datos desde Odoo, cómo se procesan en el backend de Flask y cómo se presentan en el frontend.
            </p>
        </section>

        <section id="flujo-sales">
            <h2><i class="bi bi-table"></i>Flujo de Datos: Ventas (/sales)</h2>
            <p>
                Esta sección muestra un listado paginado y filtrable de todas las líneas de facturas de venta que pertenecen al canal internacional.
            </p>

            <h3>1. Interfaz de Usuario (<code>templates/sales.html</code>)</h3>
            <p>
                La interfaz contiene un formulario de filtros que envía los parámetros al backend.
            </p>
            <ul>
                <li><strong>Método de Envío:</strong> El formulario utiliza <code>method="POST"</code> para enviar los filtros. La paginación funciona con parámetros GET en la URL (ej. <code>?page=2</code>).</li>
                <li><strong>Campos de Filtro:</strong> Se incluyen campos para rango de fechas (<code>date_from</code>, <code>date_to</code>), un término de búsqueda general (<code>search_term</code>) y un selector de clientes (<code>partner_id</code>).</li>
                <li><strong>Renderizado:</strong> Los datos recibidos del backend en la variable <code>sales_data</code> se iteran para construir las filas de la tabla. El objeto <code>pagination</code> se usa para generar los controles de paginación.</li>
            </ul>

            <h3>2. Backend (<code>app.py</code> - ruta <code>/sales</code>)</h3>
            <p>
                La función <code>sales()</code> orquesta todo el proceso en el servidor.
            </p>
            <ol>
                <li><strong>Recepción de Filtros:</strong> Lee los parámetros de filtro desde <code>request.form</code> (para POST) o <code>request.args</code> (para GET). Esto permite que los filtros persistan al cambiar de página.</li>
                <li><strong>Llamada al Manager:</strong> Invoca a <code>data_manager.get_sales_lines()</code>, pasando los filtros y los parámetros de paginación (<code>page</code>, <code>per_page</code>).</li>
                <li><strong>Manejo de Paginación:</strong> Recibe una tupla <code>(datos, paginacion)</code> del manager. El objeto <code>pagination</code> contiene el total de registros, número de páginas, etc.</li>
                <li><strong>Renderizado:</strong> Pasa los datos de ventas filtrados y el objeto de paginación a la plantilla <code>sales.html</code>.</li>
            </ol>

            <h3>3. Capa de Datos (<code>odoo_manager.py</code> - método <code>get_sales_lines</code>)</h3>
            <p>
                Este es el núcleo de la extracción de datos. Se conecta a Odoo y construye una consulta compleja.
            </p>
            
            <h4>Modelo Principal de Odoo</h4>
            <p>La consulta se realiza sobre el modelo <code>account.move.line</code> (líneas de asiento contable).</p>

            <h4>Construcción del Dominio (Filtros)</h4>
            <p>El dominio de la consulta se construye combinando filtros estáticos y dinámicos:</p>
            <ul>
                <li><strong>Filtros Estáticos (Hardcoded):</strong>
                    <ul>
                        <li><code>('move_id.journal_id.name', '=', 'F150 (Venta exterior)')</code>: Asegura que solo se obtengan facturas del diario de ventas internacionales.</li>
                        <li><code>('move_id.state', '=', 'posted')</code>: Solo facturas confirmadas.</li>
                        <li><code>('account_id.code', '=like', '70%')</code>: Solo líneas que afectan a cuentas de ingresos (que empiezan con 70).</li>
                        <li><code>('tax_ids.name', 'ilike', 'EXE_IGV_EXP')</code>: Filtra por el impuesto específico de exportación.</li>
                        <li><code>('product_id', '!=', False)</code>: Excluye líneas que no están asociadas a un producto.</li>
                    </ul>
                </li>
                <li><strong>Filtros Dinámicos (del usuario):</strong>
                    <ul>
                        <li><strong>Fechas:</strong> Se añaden condiciones <code>('move_id.invoice_date', '>=', date_from)</code> y <code>('move_id.invoice_date', '<=', date_to)</code>.</li>
                        <li><strong>Cliente:</strong> Se añade <code>('move_id.partner_id', '=', partner_id)</code>.</li>
                        <li><strong>Búsqueda:</strong> Se construye una condición <code>OR</code> compleja para buscar el término <code>search</code> en el nombre de la factura, origen, nombre/código del producto y nombre del cliente.</li>
                    </ul>
                </li>
            </ul>

            <h4>Campos Obtenidos de Odoo</h4>
            <p>La consulta principal a <code>account.move.line</code> solicita campos clave como:</p>
            <pre><code>'move_id', 'partner_id', 'product_id', 'balance', 'move_name', 'quantity', 'price_unit', 'amount_currency', 'display_name'</code></pre>
            <div class="note">
                <strong><i class="bi bi-translate"></i>Idioma:</strong> Todas las consultas que extraen nombres de campos (como productos o clientes) incluyen <code>'context': {'lang': 'es_PE'}</code> para obtener las traducciones en español directamente desde Odoo.
            </div>

            <h4>Obtención de Datos Relacionados</h4>
            <p>
                Después de obtener las líneas base, se realizan consultas adicionales para enriquecer los datos, usando los IDs recolectados:
            </p>
            <ol>
                <li><strong>Facturas (<code>account.move</code>):</strong> Se obtienen detalles de las facturas (fecha, origen, vendedor, etc.).</li>
                <li><strong>Productos (<code>product.product</code>):</strong> Se obtienen todos los detalles del producto, incluyendo <code>display_name</code>, línea comercial, clasificación farmacológica, etc.</li>
                <li><strong>Clientes (<code>res.partner</code>):</strong> Se obtienen el nombre y país del cliente.</li>
                <li><strong>Pedidos (<code>sale.order</code>):</strong> Si la factura tiene un pedido de origen, se obtienen sus detalles.</li>
            </ol>

            <h4>Estructura Final</h4>
            <p>Finalmente, se ensambla una lista de diccionarios, donde cada diccionario representa una línea de venta con todos los datos combinados, lista para ser mostrada en la tabla.</p>
        </section>

        <section id="flujo-pending">
            <h2><i class="bi bi-clock-history"></i>Flujo de Datos: Pendientes (/pending)</h2>
            <p>
                Esta sección es muy similar a <code>/sales</code>, pero se enfoca en mostrar las líneas de pedidos de venta que aún no han sido completamente facturadas.
            </p>

            <h3>1. Interfaz y Backend (<code>templates/pending.html</code> y <code>app.py</code>)</h3>
            <p>
                El flujo es prácticamente idéntico al de la vista de ventas: el formulario envía los filtros, la ruta <code>pending()</code> en <code>app.py</code> los recibe y llama a <code>data_manager.get_pending_orders()</code>, pasando el resultado a la plantilla.
            </p>

            <h3>2. Capa de Datos (<code>odoo_manager.py</code> - método <code>get_pending_orders</code>)</h3>
            <p>
                La diferencia fundamental radica en el modelo y los filtros utilizados en Odoo.
            </p>

            <h4>Modelo Principal de Odoo</h4>
            <p>La consulta se realiza sobre el modelo <code>sale.order.line</code> (líneas de pedido de venta).</p>

            <h4>Construcción del Dominio (Filtros)</h4>
            <ul>
                <li><strong>Filtros Estáticos (Hardcoded):</strong>
                    <ul>
                        <li><code>('order_id.team_id.name', 'ilike', 'INTERNACIONAL')</code>: Filtra por pedidos asignados al equipo de ventas internacional.</li>
                        <li><code>('order_id.state', 'in', ['credit', 'sale', 'done'])</code>: Solo pedidos en estados relevantes (aprobados para crédito, confirmados o finalizados pero con saldo pendiente).</li>
                        <li><code>('product_id', '!=', False)</code>: Asegura que la línea tenga un producto asociado.</li>
                    </ul>
                </li>
                <li><strong>Filtros Dinámicos (del usuario):</strong>
                    <ul>
                        <li>Se aplican filtros de fecha, cliente y búsqueda de manera similar a <code>get_sales_lines</code>, pero sobre los campos del pedido (<code>order_id</code>).</li>
                    </ul>
                </li>
            </ul>

            <h4>Lógica de "Pendiente"</h4>
            <p>
                Una línea se considera "pendiente" si su campo <code>qty_to_invoice</code> es mayor que cero. Este campo es calculado por Odoo y representa la cantidad que aún falta por facturar. Para pedidos en estado <code>credit</code>, este valor se calcula manualmente como <code>product_uom_qty - qty_invoiced</code>.
            </p>

            <h4>Campos y Datos Relacionados</h4>
            <p>
                El proceso es análogo al de ventas:
            </p>
            <ol>
                <li>Se obtienen las líneas de pedido de venta (<code>sale.order.line</code>) que cumplen con el dominio.</li>
                <li>Se filtran aquellas con <code>qty_to_invoice > 0</code>.</li>
                <li>Se recolectan los IDs de los pedidos (<code>order_id</code>), productos (<code>product_id</code>) y clientes (<code>partner_id</code>).</li>
                <li>Se realizan consultas secundarias a los modelos <code>sale.order</code>, <code>product.product</code> y <code>res.partner</code> para obtener los detalles completos.</li>
                <li>Se ensambla la estructura de datos final, calculando el <code>total_pendiente</code> para cada línea.</li>
            </ol>

        </section>

        <section id="sistema-cache">
            <h2><i class="bi bi-lightning-charge-fill"></i> Sistema de Caché</h2>
            <p>
                Para mejorar el rendimiento y reducir la carga en el servidor de Odoo, la aplicación implementa un sistema de caché en memoria, especialmente en la ruta más consultada y costosa: el <strong>Dashboard Principal</strong> (<code>/dashboard</code>).
            </p>

            <h3>1. Propósito del Caché</h3>
            <p>
                La carga del dashboard principal implica múltiples y complejas consultas a Odoo para obtener ventas, pedidos pendientes y datos relacionados. Estas operaciones pueden ser lentas. El caché almacena el resultado de una petición ya procesada durante un tiempo determinado. Si otro usuario (o el mismo) realiza la misma petición dentro de ese tiempo, la aplicación devuelve la respuesta guardada en lugar de volver a consultar y procesar todo desde cero.
            </p>
            <ul>
                <li><strong>Mejora la velocidad:</strong> Las cargas subsiguientes de la página son casi instantáneas.</li>
                <li><strong>Reduce la carga de la API:</strong> Disminuye drásticamente el número de llamadas a Odoo.</li>
            </ul>

            <h3>2. Implementación (<code>app.py</code>)</h3>
            <p>
                Se utiliza la librería <code>Flask-Caching</code>. La configuración se define al inicio de <code>app.py</code>:
            </p>
            <pre><code># --- Configuración de Caché ---
cache_config = {
    "CACHE_TYPE": "SimpleCache",  # Almacenamiento en memoria simple
    "CACHE_DEFAULT_TIMEOUT": 600  # 10 minutos de caché por defecto
}
cache = Cache(config=cache_config)
cache.init_app(app)</code></pre>
            <p>
                Luego, se aplica un decorador a la ruta del dashboard:
            </p>
            <pre><code>@app.route('/dashboard', methods=['GET', 'POST'])
@cache.cached(timeout=600, query_string=True)
def dashboard():
    # ... lógica de la función ...</code></pre>

            <h4>Análisis del Decorador <code>@cache.cached</code></h4>
            <ul>
                <li>
                    <code>timeout=600</code>: Especifica que el resultado de esta ruta se almacenará en caché durante <strong>600 segundos (10 minutos)</strong>. Después de este tiempo, la primera petición que llegue volverá a ejecutar la función y renovará el caché.
                </li>
                <li>
                    <code>query_string=True</code>: Este es un parámetro crucial. Le indica al sistema de caché que cree una entrada de caché diferente para cada combinación de parámetros en la URL. Por ejemplo:
                    <ul>
                        <li><code>/dashboard</code> tendrá su propio caché.</li>
                        <li><code>/dashboard?cliente_id=123</code> tendrá un caché completamente separado.</li>
                        <li><code>/dashboard?cliente_id=456</code> tendrá otro caché distinto.</li>
                    </ul>
                    Esto asegura que cuando un usuario filtra por un cliente específico, vea los datos correctos para ese cliente y no los datos cacheados de "Todos los clientes".
                </li>
            </ul>
            <div class="note">
                <strong><i class="bi bi-exclamation-triangle-fill"></i>Importante:</strong> El caché se invalida automáticamente después del `timeout`. Si se necesita forzar una actualización de datos antes de tiempo, sería necesario reiniciar la aplicación Flask.
            </div>
        </section>

        <section id="integracion-google-sheets">
            <h2><i class="bi bi-file-earmark-spreadsheet-fill"></i> Integración con Google Sheets</h2>
            <p>
                La aplicación utiliza Google Sheets como una base de datos simple y accesible para gestionar toda la información relacionada con las <strong>metas de venta</strong> y la <strong>composición de los equipos comerciales</strong>. La clase <code>GoogleSheetsManager</code> en <code>google_sheets_manager.py</code> encapsula toda la lógica de esta interacción.
            </p>

            <h3>1. Autenticación y Configuración</h3>
            <p>
                La conexión se establece utilizando una <strong>Cuenta de Servicio</strong> de Google Cloud.
            </p>
            <ul>
                <li><strong>Credenciales:</strong> Se requiere un archivo <code>credentials.json</code>, que contiene las claves de la cuenta de servicio. Este archivo debe estar en la raíz del proyecto.</li>
                <li><strong>Permisos:</strong> La dirección de correo electrónico de la cuenta de servicio (que se encuentra dentro de <code>credentials.json</code>) debe tener permisos de editor sobre el documento de Google Sheets que se va a utilizar.</li>
                <li><strong>Nombre de la Hoja:</strong> El nombre del documento de Google Sheets se especifica en la variable de entorno <code>GOOGLE_SHEET_NAME</code> en el archivo <code>.env</code>.</li>
            </ul>

            <h3>2. Estructura de Datos en Google Sheets</h3>
            <p>
                El sistema espera que el documento de Google Sheets contenga varias pestañas (hojas de cálculo) con una estructura específica, donde los datos se almacenan en formato JSON en una única celda (generalmente <code>A1</code>) para simplificar la lectura y escritura.
            </p>
            <ul>
                <li>
                    <strong><code>metas_linea</code>:</strong> Almacena las metas mensuales por línea comercial. La estructura es un diccionario donde la clave es el mes (<code>YYYY-MM</code>) y el valor es otro diccionario con las metas.
                    <pre><code>{
    "2024-01": {
        "metas": {"petmedica": 10000, "agrovet": 15000},
        "metas_ipn": {"petmedica": 3000, "agrovet": 5000}
    }, ...
}</code></pre>
                </li>
                <li>
                    <strong><code>equipos</code>:</strong> Define qué vendedores pertenecen a cada equipo. La clave es el ID del equipo y el valor es una lista de IDs de vendedores.
                    <pre><code>{
    "petmedica": [10, 15, 22],
    "agrovet": [12, 18]
}</code></pre>
                </li>
                <li>
                    <strong><code>metas_vendedor</code>:</strong> Almacena las metas individuales de cada vendedor. Es una estructura anidada: <code>equipo -> vendedor_id -> mes -> {meta, meta_ipn}</code>.
                    <pre><code>{
    "petmedica": {
        "10": {
            "2024-01": {"meta": 5000, "meta_ipn": 1500},
            "2024-02": {"meta": 5500, "meta_ipn": 1600}
        }
    }, ...
}</code></pre>
                </li>
            </ul>

            <h3>3. Flujo de Lectura y Escritura</h3>
            <p>
                Las rutas de Flask como <code>/meta</code> y <code>/metas_vendedor</code> utilizan el <code>GoogleSheetsManager</code> para gestionar estos datos.
            </p>
            <ol>
                <li><strong>Lectura (GET):</strong> Cuando un usuario visita una página de metas, <code>app.py</code> llama a un método de lectura (ej. <code>gs_manager.read_metas()</code>). Este método lee el contenido JSON de la celda <code>A1</code> de la hoja correspondiente y lo deserializa en un diccionario de Python.</li>
                <li><strong>Procesamiento:</strong> La aplicación utiliza este diccionario para rellenar los formularios y tablas que ve el usuario.</li>
                <li><strong>Escritura (POST):</strong> Cuando el usuario guarda los cambios, <code>app.py</code> recolecta los datos del formulario, reconstruye el diccionario de Python con la nueva información y llama a un método de escritura (ej. <code>gs_manager.write_metas()</code>). Este método serializa el diccionario a una cadena JSON y la escribe de nuevo en la celda <code>A1</code>, sobrescribiendo los datos anteriores.</li>
            </ol>
        </section>

        <section id="logica-dashboards">
            <h2><i class="bi bi-calculator-fill"></i> Lógica de los Dashboards</h2>
            <p>
                Esta sección detalla cómo se procesan y calculan los datos para las vistas principales del dashboard, que son las más complejas de la aplicación.
            </p>

            <h3>1. Dashboard Internacional (<code>/dashboard</code>)</h3>
            <p>
                Esta vista consolida las ventas y pedidos pendientes del canal internacional para el año en curso (o un rango de fechas específico si se implementara).
            </p>
            <h4>Flujo de Datos</h4>
            <ol>
                <li><strong>Obtención de Datos Crudos:</strong> La función llama a <code>data_manager.get_sales_lines()</code> para obtener todas las líneas de facturas del período y a <code>data_manager.get_pending_orders()</code> para los pedidos pendientes. Ambas llamadas se pueden filtrar por un <code>partner_id</code> (cliente).</li>
                <li><strong>Cálculo de KPIs Principales:</strong>
                    <ul>
                        <li><strong>Ventas Totales del Año:</strong> Se calcula sumando el campo <code>amount_currency</code> de todos los registros devueltos por <code>get_sales_lines</code>.</li>
                        <li><strong>Total Por Facturar:</strong> Se calcula sumando el campo <code>total_pendiente</code> de todos los registros de <code>get_pending_orders</code>.</li>
                        <li><strong>Meta y Brecha:</strong> La meta actualmente se establece en 0. La brecha es la diferencia entre la proyección (Ventas + Por Facturar) y esta meta.</li>
                    </ul>
                </li>
                <li><strong>Agregación para Tabla Principal:</strong>
                    <ul>
                        <li>Se inicializa un diccionario <code>ventas_por_linea</code>. Se itera sobre los datos de ventas y se agrupan las sumas de <code>amount_currency</code> por el nombre de la línea comercial internacional (<code>commercial_line_international_id</code>).</li>
                        <li>De forma similar, se itera sobre los datos pendientes y se agrupan en <code>por_facturar_por_linea</code>.</li>
                        <li>Finalmente, se combinan ambos diccionarios para construir la tabla que el usuario ve en pantalla.</li>
                    </ul>
                </li>
                <li><strong>Preparación de Datos para Gráficos:</strong>
                    <ul>
                        <li><strong>Top 7 Productos:</strong> Se agrupan las ventas por nombre de producto (<code>name</code>) y se ordenan de mayor a menor para tomar los 7 primeros.</li>
                        <li><strong>Análisis Jerárquico (Drilldown):</strong> Se utiliza la librería <code>pandas</code> para convertir los datos de ventas en un DataFrame. Luego, se realizan agrupaciones sucesivas (<code>groupby</code>) por <code>linea_comercial_nombre</code>, <code>clasificacion_farma_nombre</code> y <code>producto_nombre</code> para construir la estructura de datos jerárquica que espera el gráfico ECharts.</li>
                        <li><strong>Avance por Cliente (Bullet Chart):</strong> Se crean dos diccionarios, uno para agrupar las ventas facturadas por cliente y otro para los pendientes. Luego se unen para obtener el total de pedido (facturado + pendiente) y el avance para cada cliente.</li>
                    </ul>
                </li>
            </ol>

            <h3>2. Dashboard Nacional por Línea (<code>/dashboard_linea</code>)</h3>
            <p>
                Esta vista se enfoca en el rendimiento de un equipo de ventas nacional específico durante un mes determinado, comparando sus ventas con las metas asignadas.
            </p>
            <h4>Flujo de Datos</h4>
            <ol>
                <li><strong>Recepción de Filtros:</strong> La función obtiene el mes (<code>mes_seleccionado</code>) y la línea comercial (<code>linea_seleccionada_nombre</code>) de los parámetros de la URL. También permite un filtro por día (<code>dia_fin</code>).</li>
                <li><strong>Obtención de Datos Crudos:</strong>
                    <ul>
                        <li>Llama a <code>gs_manager.read_metas()</code> para obtener todas las metas de todos los vendedores desde Google Sheets.</li>
                        <li>Llama a <code>data_manager.get_sales_lines()</code> para obtener las ventas del mes seleccionado.</li>
                    </ul>
                </li>
                <li><strong>Filtrado y Procesamiento de Ventas:</strong>
                    <ul>
                        <li>Se itera sobre los datos de ventas y se descartan explícitamente las que pertenecen a "VENTA INTERNACIONAL".</li>
                        <li>Se agrupan las ventas por vendedor (<code>invoice_user_id</code>) en diccionarios separados: <code>ventas_por_vendedor</code> (total) y <code>ventas_ipn_por_vendedor</code> (solo productos con `product_life_cycle == 'nuevo'`).</li>
                        <li>Las notas de crédito o ajustes sin un vendedor asignado se suman en una variable separada (<code>ajustes_sin_vendedor</code>).</li>
                    </ul>
                </li>
                <li><strong>Construcción de la Tabla de Vendedores:</strong>
                    <ul>
                        <li>Se obtiene la lista de miembros "oficiales" del equipo desde Google Sheets (<code>gs_manager.read_equipos()</code>).</li>
                        <li>Se unifica esta lista con los IDs de los vendedores que tuvieron ventas reales en esa línea durante el mes (para incluir a vendedores que vendieron en la línea sin ser miembros oficiales).</li>
                        <li>Se itera sobre esta lista unificada. Para cada vendedor, se obtienen sus ventas (de los diccionarios de agregación) y sus metas (del diccionario de metas de Google Sheets).</li>
                        <li>Se construye la fila de la tabla para cada vendedor, calculando sus porcentajes de avance.</li>
                    </ul>
                </li>
                <li><strong>Cálculo de KPIs de Línea:</strong>
                    <ul>
                        <li>Se suman las metas y ventas de todos los vendedores para obtener los totales de la línea.</li>
                        <li>Se calculan los KPIs generales (avance total, avance IPN, ritmo diario requerido, etc.) que se muestran en la parte superior.</li>
                    </ul>
                </li>
            </ol>
        </section>

    </main>

    <script>
        // Script para resaltar la sección activa en la tabla de contenidos
        document.addEventListener('DOMContentLoaded', () => {
            const sections = document.querySelectorAll('section');
            const navLinks = document.querySelectorAll('#toc a');

            const observer = new IntersectionObserver(entries => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        navLinks.forEach(link => {
                            link.classList.remove('active');
                            if (link.getAttribute('href').substring(1) === entry.target.id) {
                                link.classList.add('active');
                            }
                        });
                    }
                });
            }, { threshold: 0.3 });

            sections.forEach(section => {
                observer.observe(section);
            });
        });
    </script>

</body>
</html>